@top Script { line* }

@precedence {
  restrictedPath @left,
  pathComponent @left,
  list @left,
  parens @left,
  mod @left,
  divide @left,
  multiply @left,
  subtract @left,
  add @left,
  presence @left,
  comparison @left,
  andOr @left,
  functionCall @left,
  variableName @left,
  blockCase @left,
  emptyLine @left,
  keyword @left,
  condition @left,
  choiceDivert @left,
  choice @left,
  content @left
}

line {
  AuthorWarning |
  ContentLine |
  Include |
  VariableDeclaration |
  ConstDeclaration |
  ListDeclaration |
  VariableAssignment |
  choice |
  knotOrFunction |
  Stitch |
  Gather |
  ThreadLine |
  conditionalLine |
  BlockSequence |
  emptyLine
}

@skip { (spaces | BlockComment) }

ContentLine { ~opening !content (Glue? content* ((Glue? | Tag*) | (Tag* | Glue?)) Divert?) endOfLine }
AuthorWarning { ~opening !keyword todo notEol+ eol }
todo[@dynamicPrecedence=1] { @extend<contentWord, "TODO:"> }
Include { ~opening !keyword opener<"INCLUDE"> notEol+ eol }
emptyLine[@dynamicPrecedence=2] { ~opening !emptyLine endOfLine }

content {
  contentWord | contentEscape | inline
}

// Knots and Stitches
knotOrFunction {
  Knot | Function
}
Function { knotMarker ~functionOrKnot kw<"function"> knotOrFunctionTail }
Knot { knotMarker ~functionOrKnot knotOrFunctionTail }
knotOrFunctionTail { Name KnotArguments? knotMarker? endOfLine }
KnotArguments { "(" commaSep<knotArgument> ")" }
knotArgument { kw<"ref">? Name }
Stitch { ~opening stitchMarker Name KnotArguments? stitchMarker? endOfLine }
Gather { ~opening (!keyword gatherMarker) BracketedName? ContentLine }

// To avoid issues with dashes being "mis-tokenized" midline, we need
// the gather marker at the line start to be an extension of the broader
// contentWord token. Unfortunately, extending going only be done with
// literal values, so we are limited to supporting a fixed depth of gathers.
gatherMarker {
  opener<"-"> |
  opener<"--"> |
  opener<"---"> |
  opener<"----"> |
  opener<"-----"> |
  opener<"------"> |
  opener<"-------">
}

// Declarations
VariableDeclaration {
  ~opening !keyword opener<"VAR"> Name "=" (literal | ExpressionList | ExpressionDivertTarget)  endOfLine
}
ConstDeclaration {
  ~opening !keyword opener<"CONST"> Name "=" (literal | ExpressionList | ExpressionDivertTarget) endOfLine
}
ListDeclaration {
  ~opening !keyword opener<"LIST"> Name "=" endOfLine? ListDefinition endOfLine
}
ListDefinition {
  (Name | SelectedName) ("," endOfLine? (Name | SelectedName))*
}
SelectedName {
  "(" identifier ")"
}

// Assignments
VariableAssignment {
  !keyword assignmentMarker ("temp" | "return")? Name (variableAssignValue | Adjust | IncDec) endOfLine
}
variableAssignValue {
  "=" (literal | ExpressionList | ExpressionDivertTarget | Name)
}
Adjust {
  ("+=" | "-=") (literal | Name)
}
IncDec {
  "++" | "--"
}

// Choices
choice { OnceOnlyChoice | RepeatingChoice }
OnceOnlyChoice {
  onceOnlyChoiceMarker choiceTail
}
RepeatingChoice {
  repeatingChoiceMarker choiceTail
}
choiceTail {
  BracketedName? (!condition ChoiceCondition)* preweaveChoiceContent? (WeaveBracket choiceContent*)? ChoiceTag* Divert? endOfLine
}
preweaveChoiceContent { ((choiceContentWord | contentEscape) choiceContent*) }
BracketedName { openBracketedName identifier ")" }
WeaveBracket { openWeaveBracket choiceContent* ChoiceTag* "]" }
choiceContent {
  choiceContentWord | contentEscape | inline
}
ChoiceCondition { "{" ~bracket expression "}" }

// Blocks
@external tokens checkBrace from "./tokens" {
  inlineConditionalOpen,
  inlineSequenceOpen,
  blockOpen
}

inline {
  Conditional | InlineSequence
}

Conditional {
   "{" ~bracket inlineConditionalOpen conditionMarker? expression ":" content+ Divert? "}"
}
BlockConditional {
  "{" ~bracket blockOpen conditionMarker? expression ":" (ContentLine | emptyLine) blockTail |
  "{" ~bracket endOfLine blockTail
}
blockTail {
  (BlockConditionCase | ~case ContentLine | ~case choice | ~case VariableAssignment)*
  "}"
}
BlockConditionCase { caseOpener expression ":" (ContentLine | emptyLine) }
caseOpener[@dynamicPrecedence=1] { ~case opener<"-"> }
conditionalLine { !keyword BlockConditional endOfLine }

BlockSequence {
  "{" ~bracket blockOpen blockSequenceKeyword ":" endOfLine
  (BlockSequenceItem | ContentLine)+
  "}" endOfLine
}
BlockSequenceItem { caseOpener ContentLine }

blockSequenceKeyword {
  kw<"stopping"> | kw<"shuffle"> | kw<"cycle"> | kw<"once">
}

InlineSequence {
  "{" ~bracket inlineSequenceOpen SequenceTypeMarker? pipeSep1<SequenceContent> "}"
}
SequenceContent { content* Divert? }

// Tags
Tag { "#" openTagContent+  }
ChoiceTag { "#" (choiceTagContent | choiceTagNotDivert)+ }

// Threads
ThreadLine { !keyword threadArrow DivertTarget endOfLine }

// Logic
Name { !parens identifier }

expression[@isGroup=Expression] {
    binaryOperator {
      ExpressionAndOr { expression !andOr andOrOp expression } |
      ExpressionComparison { expression !comparison comparisonOp expression } |
      ExpressionPresence { expression !presence presenceOp expression } |
      ExpressionMod { expression !add ("%" | "mod") expression } |
      ExpressionAdd { expression !add "+" expression } |
      ExpressionSubtract { expression !subtract "-" expression } |
      ExpressionMultiply { expression !multiply "*" expression } |
      ExpressionDivide { expression !divide "/" expression }
    } |
    ExpressionParen { !parens "(" expression ")" } |
    ExpressionNot { kw<"not"> expression } |
    ExpressionFunctionCall { !functionCall Name "(" commaSep<expression> ")" } |
    ExpressionVariableReference { !variableName Name } |
    ExpressionList |
    ExpressionDivertTarget |
    literal
}

ExpressionDivertTarget { DivertArrow DivertTarget }
ExpressionList { !list "(" commaSep<ListMember> ")" } 

literal[@isGroup=Literal] {
  Bool |
  String |
  Int |
  Float
}

Bool { kw<"true"> | kw<"false"> }
String { string }
Int { int }
Float { float }

@local tokens {
  stringEnd { '"' }
  stringEscape { "\\" _ }
  @else stringContent
}

@skip {} { string { '"' (stringContent | stringEscape)* stringEnd } }

ListMember {
  !list identifier ("." identifier)?
}

// Diverts
Divert {
    DivertArrow DivertTarget?
}

DivertTarget {
  (!pathComponent Path) | !restrictedPath kw<"END"> | !restrictedPath kw<"DONE">
}

Path {
  identifier ("." identifier)?
}

// Comments
@skip {} { BlockComment { blockCommentStart commentContent blockCommentEnd } }

@local tokens {
  blockCommentEnd { "*/" }
  @else commentContent
}

LineComment { lineCommentStart notEol+ eol }

commaSep<content> {
  (content ("," content)*)?
}
pipeSep1<content> {
  (content (Pipe content)*)
}
kw<word> { @specialize[@name={word}]<identifier, word> }
opener<word> { @extend<contentWord, word> }
endOfLine { eol | LineComment }

@tokens {
  spaces { $[ \t] }
  notEol { ![\n\r] }
  eol { $[\n\r] }

  Glue { "<>" }

  andOrOp { "&&" | "||" | "and" | "or" }
  comparisonOp { "==" | "<" "="? | ">" "="? | "!=" }
  presenceOp { "?" | "has" "nt"? | "!?" | "^" }
  contentEscape { "\\" _ }
  contentChar { ![\n\r \t{}#\\|]  }
  contentWord { contentChar+ }

  choiceContentChar { ![\n\r \t{}#\\|[\]] }
  choiceContentWord { choiceContentChar+ }
  choiceTagContent { ![\n\r#\[\]-] }
  choiceTagNotDivert { "-" ![>] }

  onceOnlyChoiceMarker { "*"+ }
  repeatingChoiceMarker { "+"+ }

  openTagContent { ![\n\r#] }

  int { @digit+ }
  float { @digit+ "." @digit* }

  identifierChar { (identifierStartChar | @digit | "_") }
  identifierStartChar { @asciiLetter | $[\u0600-\u06FF\u0530-\u058F\u0400-\u04FF\u0370-\u03FF\u0590-\u05FF\u0100-\u017F\u0180-\u024F\u0080-\u00FF] }
  identifier { identifierStartChar identifierChar* }

  DivertArrow { "->" "->"? }
  threadArrow { "<-" }
  blockCommentStart { "/*" }
  lineCommentStart { "//" }
  SequenceTypeMarker { "~" | "&" | "!" }
  conditionMarker { "-" }
  Pipe { "|" }
  assignmentMarker { "~" }
  knotMarker { "=" "="+ }
  stitchMarker { "=" }
  openBracketedName { "(" }
  openWeaveBracket { "[" }

  @precedence { knotMarker, stitchMarker, contentWord }
  @precedence { openBracketedName, contentWord }
  @precedence { openBracketedName, choiceContentWord }
  @precedence { DivertArrow, choiceTagContent }
  @precedence { float, int, identifier }
  @precedence { spaces, notEol }
  @precedence { presenceOp, comparisonOp }
  @precedence { DivertArrow, Glue, contentWord }
  @precedence { DivertArrow, Glue, choiceContentWord }
  @precedence { DivertArrow, openTagContent, spaces }
  @precedence { "temp", "return", identifier }
  @precedence { assignmentMarker, contentWord }
  @precedence { SequenceTypeMarker, contentWord }
  @precedence { conditionMarker, contentWord }
  @precedence { SequenceTypeMarker, choiceContentWord }
  @precedence { conditionMarker, choiceContentWord }
  @precedence { blockCommentStart, lineCommentStart, contentWord }
  @precedence { blockCommentStart, lineCommentStart, choiceContentWord }
  @precedence { "(", choiceContentWord }
  @precedence { choiceTagContent, spaces }
  @precedence { onceOnlyChoiceMarker, repeatingChoiceMarker, contentWord }
  @precedence { threadArrow, contentWord }
}